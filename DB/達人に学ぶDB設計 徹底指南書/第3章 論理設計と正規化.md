# 現状の課題
+ 正規化の目的ややり方が理解できていない。
+ だから、「正しく正規化できた」と自信を持って言い切れない。

# 目標
+ 正規化の目的ややり方を正しく理解し、正しく正規化できたと言える状態になること

# テーブル
## リレーショナルDBにおけるテーブルと表って違うの？
+ 表は使う人が自由に設定しても構わないが、テーブルにはルールがある。
+ そのルールとは、「テーブルとはある共通点を持ったレコードの集合のこと」
+ 例えば、社員テーブルは、一つのレコードはある社員の情報を表現していおり、「社員情報を示す」というルールでカテゴライズしている。
+ 一方表は、それがどうゆう表であるかも、セルの中にどのような値を設定するかも、必ずしもルールを決める必要がない。
+ テーブル名は、複数形もしくは複数名詞で書ける

## テーブルの構成要素
+ 行と列
+ キー

## キー
### キーとは
あるレコードを特定するための列の組み合わせのこと

### キーの種類
1. 主キー
2. 外部キ

### 主キーとは何か
+ その値を指定すれば、ある一行のレコードを特定できる列の組み合わせのこと
+ テーブルには必ず主キーがあり、主キーは一つしか存在しない
+ 主キーがある＝レコードを一意に識別できる＝そのテーブルには、全く同じ行は存在しないということ

### それが主キーになり得るか判断するためには
+ その値を指定したら、必ずある一つのレコードを特定できるか（複数のレコードが返ってこないか）

### 外部キーって何?
+ 別のテーブルを参照する機能を持った列・値のこと
+ 参照する側と参照される側の２つのテーブル同士に設定するもの

### 外部キーはどんな時に使われるのか?
+ 親子関係が成立している時
+ つまり、子供のいない親はありえるが、子のいない親は存在しないという関係性が成り立つ
+
### 外部キーを設けると何が良いのか？
+ 「親テーブルに存在しないデータを子が設定する」という状態を防ぐことができる。（これを参照整合性制約という）
+ 逆に、親テーブルは子テーブルに関係なく、データを登録できる。
+　　親テーブルのあるデータが削除・変更されたら、それを参照ている子も同じように振る舞うかどうか制御することができる。

### もし親が削除・変更されたら、その子はどうなるのか？
+ 子も同様に振る舞うのか、依存させないのかはユーザーが選ぶことができる
+ 親が削除されたら、子も同じように削除することを「カスケード」という

# 制約
## 制約って何？
+ テーブルに対して、制限をかけること

## 例えば?
## 参照整合性制約
+ その名の通り、参照する際の整合性を保つための制約のこと
+ これは外部キーを設けることで、「テーブルAのある列は、テーブルBを参照するよ！」と宣言することで、
+ テーブルBを参照してテーブルAの列が決まる以上、テーブルAは独自に新しい値を決めれないように制約をかける。
+ こうすることで、参照する側とされる側で整合性を保つことができるようになる。

## NOTNULL制約
+ ある列の空白を許さないようにするということ
+ 必ず値を設定しないと登録できないように制限できる
+ 主キーはNOTNULL制約である。なぜなら、主キーは重複を許さないから。

## 一意制約
+ ある列の値が重複することを防ぐこと
+ 主キーも同様の機能を持っているが、主キーは一つのテーブルに対して、z一つしか設定できないが、一意制約は複数の列に設定できる。

### 外部キーはどんな時に使われるのか?
## 一意制約

# 正規化
## 正規化って何?
データの冗長性（ムダのこと）を排除し、データに一貫性があり、かつ効率的にデータが扱えるようなテーブルにする行為・その方法論のこと

## 冗長的なデータって例えばどんなの？

## どうやって冗長的なデータを排除するの？
+ 段階的に正規化を行っていく
+ 正規化は1~5段階の過程があるが、一般的には第３正規化まで理解していれば問題
+ 各段階の正規化を順に見ていこう!

### 第一正規化
#### 第一正規化とは？
+ 一つのセル（便宜上、行列に交差するマスのことをセルという。）に複数の値が含まれる状態を無くす作業のこと
+ 
#### 第一正規化のゴールは？
+ 一つのセルには一つの値しかないテーブルにすることがゴールになります。
+ この「一つのセルには一つの値しか含まれない」ことを、スカラ値の原則といいます。
+ 言い換えると、第一正規化のゴールはスカラ値の原則を満たすことになります。

#### 「一つのセルに複数の値が入っていること」の何が問題なの？
+ 結論から言うと、「関数従属性を満たさないから」です。
+ 関数従属性とは、「xが決まればy列の値は一つに決まる」という性質のことでです。
+ 主キーの条件に、「ある値が決まれば、ある一つのレコードが定まること」がありましたが、実は他にも条件があります。
+ それが、この関数従属性です。つまり、「主キーが決まれば、ある列の値も一意に決まる」必要があります。
+ もし「一つのセルに複数の値が入っていること」を許してしまうと、主キーを定めると、ある列で複数の値を返すことになり、関数従属性を満たさなくなります。ここが問題点です。

##### 【問い】なぜ、主キーは関数従属性を満たさないといけないのか。一つの値に対して、複数の値が含まれることの何が問題になるのか。

#### どうやって第一正規化するの？
主に２つの方法がある。

セルに含まれる値の数だけ
1. 列を増やす（列持ち）
2. セルに含まれる値の数だけ、行を増やす。つまり行分割（行持ち）
基本的には、行持ちで正規化される。

#### 行持ちによる正規化だけでは問題がある
例えば、下記のように行持ちされた、扶養を持つ社員のテーブルの場合

| 社員ID | 社員名 |扶養|
----|----|----|
|1|佳代子|太郎|
|1|佳代子|次郎|
|1|佳代子|一郎|
|2|知恵|浩二|
|3|サニー||

##### 主キーが定まらない問題
+ 社員IDだけでは一つのレコードは特定できないし、社員名を含めても同様である。一つの行を特定するためには、前列を主キーにするしかない。
+ しかし、主キーにはNULLがあってはならないルールがある。
+ サニーのように、扶養のない社員だって存在するため、NULLが存在することになる。
+ よって、行分割だけでは主キーが定まらないため問題なんです。
+ じゃあ「扶養なし」のようなデータを設定すれば良いのではないか？確かにそうだが、ここで次の問題がでてくる

##### テーブルの意味やレコードの単位がわかりづらい問題
+ 現状のテーブルだと、社員と扶養の２つの情報が一つのテーブルに含まれているため、これが何のテーブルなのか、どうゆう単位で一つのレコードとしているのか分かりづらい問題がある。
以上の理由から行持ちだけでは正規化はできても、RDBのテーブルとしての機能が果たせなくなるから問題なんです！

##### 上記の問題を解決するためには？
+ 行分割と合わせて、テーブル分割+外部キー付与も行えば良いです。
+　上記の問題は、一つのテーブルに社員と扶養の２つの情報が含まれていることが問題なため、テーブルを分割します。
+ そして、扶養テーブルに扶養ID列を設ければ、わざわざ「子なし」のような値を用意しないでも、それぞれのテーブルで主キーを定めることができます。
+ さらに、一つのテーブルには一つの情報がまとまっているため、テーブルの意味もわかりやすく、レコードの単位も明瞭になります。
+ ただしこのままでは、各テーブルが独立したままで、関係性がないため、扶養テーブルは誰の社員の子なのかわからくなります。
+ そこで、扶養テーブルに外部キーをはることで、扶養テーブルは社員テーブルを参照するようにし、テーブル間の関係性を築きます。
これにより、上記の問題をクリアしつつ、親と子の関係性を持つ要件も満たすことが可能になります。

それだけではありません。外部キーを与えたことで、
1. 社員テーブルにないデータが、扶養テーブルに登録されることを防ぎますし（参照整合性制約）
2. 社員テーブルは扶養テーブルを気にすることなく、データを登録することができます。
3. 一方で、扶養テーブルで参照している社員が更新・削除されたら、反映させることも可能になります。
上記のようなメリットから、行分割+テーブル分割+外部キー付与の３ステップをとると良いでしょう！

# 第二正規化
## 第二正規化のゴールは?
+ 第二正規形にすること
+ 第二正規形とは、完全関数従属のみのテーブルにすること
+ 完全関数従属とは、主キーを構成するすべての列が決まれば、ある列の値が定まる関係のことを言います。
+ 例えばXとY列で構成される主キーがあって、非主キーとしてZがあると仮定した場合、
+ XとYの両方が揃って初めて、Zが特定できる。これが完全関数従属です。
+ 対して「Xさえわかれば、Zが特定できる」状態は、完全関数従属といえません。これを、主キーの一部で従属が成り立つと言う意味で、部分関数従属といいます。

## どうやって第二正規形を実現するの？
+ 第二正規形とは、「完全関数従属のみのテーブルにすること」です。
+ これは、先ほど説明した「部分関数従属を無くすこと」で実現可能になります。これが第二正規化です。
+ ではどうすれば、部分関数従属を無くすことができるでしょうか？
1. 部分関数従属を特定する
2. 部分関数従属を無くす
の２ステップが必要です。

+ 部分関数従属の意味も含め、下記のa~hの列を持ったテーブルを例に解説します。

| a | b | c |d |e |f |g |h |
|----|----|----|----|----|----|----|----|

### ステップ１：部分関数従属を特定する
+ まずは部分関数従属を特定することからです。
+ 部分関数従属とは、候補キー（主キーの候補となる組み合わせのこと）の一部に、関数従属が存在することを指します。
+ 例を見ていきましょう。上記のテーブルのうち、a,b,c三列が候補キーとします。
+ さらに候補キーの各列には、以下の従属が成り立つとします。
1. 候補キーa列が決まれば、d列が決まる
2. 候補キーb列が決まれば、e列が決まる
3. 候補キーc列が決まれば、残りのf,g,h列が決まる

上記1~3はどれも、候補キーのある一部の列に関数従属が存在するため、部分関数従属になります。

よって、このテーブルには、部分関数従属が３つ存在することになります。

これが部分関数従属を特定するステップになります。

次は、部分関数従属を無くす作業に移ります！

### ステップ2：部分関数従属を無くす
+ 部分関数従属が成立している列毎に、テーブル分割を行えば部分関数従属を無くすことが可能です。
+ 上記の例で言うと、
+ テーブル①：a,d列
+ テーブル②:b,e列
+ テーブル③:c,f,g,h列

に分けます。

こうすると、それぞれのテーブルは、部分関数従属が存在しない状態になります。

この状態を作ると、結果として「全ての列が主キーに従属する」ことになります。それはつまり、完全関数従属のみのテーブルが実現され、第二正規化の完了となるわけです！

#### 従属についてもっと詳しく

##### 従属とは?
+ 「Xが決まればYが決まる」という関係のこと
+ Xを決定項、Yを被決定項という
+ XとYはそれぞれ複数になることもある
+ 例(Xが複数になる場合)：受験年度と受験科目、受験番号を決めれば、成績が分かる
+ 例(Yが複数になる場合)：ユーザーIDを決めれば、ユーザー名とメールアドレスが分かる

#### 第二正規形でないテーブルには何が起こるか？
##### 「子のない親は登録できない」問題
+ 例えば、社員とその扶養者が記載されたテーブルの場合、ある一人の扶養者を特定するには、「社員ID」「扶養者ID」が必要になり、これらが主キーになります。
+ しかし現実社会では、扶養を持たない社員も存在します
+ ところがテーブルでは、主キーである扶養IDがNULLになることは許されません。
+ このように現実社会で起こり得る「子を持たない親」を実現することができなくなります。
+ 一方、第二正規化を行えば、社員テーブルと扶養テーブルに分かれることになり、「扶養のない社員」は、社員テーブルに登録するだけで要件を満たすことが可能になります。

#### 以上の学びを踏まえて、実際にどのように第二正規化を行うか。
以上の学びを踏まえ、私は、下記のようなプロセスで第二正規化を行おうと考えている。
1. まずは難しいことを考えず、現実社会と同様に、異なる実体（エンティティ）は異なるテーブルに分け、親子関係を外部キーを設けることで表現する
2. その上で次は、「そのテーブルに部分関数従属が存在しないか」チェックする
3. 部分従属があれば、それは第二正規化されていないということだから、テーブル分割する
4. 部分従属がなければ、第二正規化できるということなので完了

# 第三正規化
## 第三正規化のゴールは？
非主キーの全ての列が、主キーに推移関数従属していない

## どうやって実現するの？
+ 推移的関数従属を無くすことで可能です。これを第三正規化と言います。

## 推移的関数従属って何？
1. 「Xが決まればYが決まる。Yが決まればZが決まる」
2. このように、段階的な関数従属のことを推移関数従属と言います。

## 「主キーに推移的関数従属していない」ってどうゆうこと?
+ 「主キーXが決まればYが決まる。Yが決まればZが決まる」という関係がないということです。

## 「主キーに推移的関数従属している列」はどうやって確認するの?
1. まず主キーに従属している列をピックアップし、
2. その列に対して従属する列がないかチェックします。
3. もし見つかれば、それは主キーに推移的関数従属している列になります。

## 「主キーに推移的関数従属していない」はどうやって実現するの?
+ X→Y→Zと、一つのテーブルないで、段階的に推移していることが問題なので、Y→Zを切り出して別のテーブルにしてあげれば良いのです。

## なぜ推移的関数従属を無くす必要があるの?
+ 先ほどの第二正規化をする理由と同様に、推移的関数従属があるテーブルでは、「親のない子」を登録できない問題があるためです。

## まとめ：第三正規化を具体的にどのように行うか?
+ 第三正規化のゴールは、「第二正規形を満たしていて、かつ非主キーの全ての列が、主キーに対して推移従属関係でないこと」のため、
1.　第二正規形でないことをチェック
2.　主キーに従属している列をピックアップ
3.　ピックアップした列に従属している列がないかチェック
4.　もしあれば、その列は、「主キーに対して推移従属関係な列」であるため、テーブル分割
5.　もしなければ、「主キーに対して推移従属関係な列は存在しない」ことになるため完了
