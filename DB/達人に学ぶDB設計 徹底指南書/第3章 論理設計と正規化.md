# 現状の課題
+ 正規化の目的ややり方が理解できていない。
+ だから、「正しく正規化できた」と自信を持って言い切れない。

# 目標
+ 正規化の目的ややり方を正しく理解し、正しく正規化できたと言える状態になること

# テーブル
## リレーショナルDBにおけるテーブルと表って違うの？
+ 表は使う人が自由に設定しても構わないが、テーブルにはルールがある。
+ そのルールとは、「テーブルとはある共通点を持ったレコードの集合のこと」
+ 例えば、社員テーブルは、一つのレコードはある社員の情報を表現していおり、「社員情報を示す」というルールでカテゴライズしている。
+ 一方表は、それがどうゆう表であるかも、セルの中にどのような値を設定するかも、必ずしもルールを決める必要がない。
+ テーブル名は、複数形もしくは複数名詞で書ける

## テーブルの構成要素
+ 行と列
+ キー

## キー
### キーとは
あるレコードを特定するための列の組み合わせのこと

### キーの種類
1. 主キー
2. 外部キ

### 主キーとは何か
+ その値を指定すれば、ある一行のレコードを特定できる列の組み合わせのこと
+ テーブルには必ず主キーがあり、主キーは一つしか存在しない
+ 主キーがある＝レコードを一意に識別できる＝そのテーブルには、全く同じ行は存在しないということ

### それが主キーになり得るか判断するためには
+ その値を指定したら、必ずある一つのレコードを特定できるか（複数のレコードが返ってこないか）

### 外部キーって何?
+ 別のテーブルを参照する機能を持った列・値のこと
+ 参照する側と参照される側の２つのテーブル同士に設定するもの

### 外部キーはどんな時に使われるのか?
+ 親子関係が成立している時
+ つまり、子供のいない親はありえるが、子のいない親は存在しないという関係性が成り立つ
+ 
### 外部キーを設けると何が良いのか？
+ 「親テーブルに存在しないデータを子が設定する」という状態を防ぐことができる。（これを参照整合性制約という）
+ 逆に、親テーブルは子テーブルに関係なく、データを登録できる。
+　　親テーブルのあるデータが削除・変更されたら、それを参照ている子も同じように振る舞うかどうか制御することができる。

### もし親が削除・変更されたら、その子はどうなるのか？
+ 子も同様に振る舞うのか、依存させないのかはユーザーが選ぶことができる
+ 親が削除されたら、子も同じように削除することを「カスケード」という

# 制約
## 制約って何？
+ テーブルに対して、制限をかけること

## 例えば?
## 参照整合性制約
+ その名の通り、参照する際の整合性を保つための制約のこと
+ これは外部キーを設けることで、「テーブルAのある列は、テーブルBを参照するよ！」と宣言することで、
+ テーブルBを参照してテーブルAの列が決まる以上、テーブルAは独自に新しい値を決めれないように制約をかける。
+ こうすることで、参照する側とされる側で整合性を保つことができるようになる。

## NOTNULL制約
+ ある列の空白を許さないようにするということ
+ 必ず値を設定しないと登録できないように制限できる
+ 主キーはNOTNULL制約である。なぜなら、主キーは重複を許さないから。

## 一意制約
+ ある列の値が重複することを防ぐこと
+ 主キーも同様の機能を持っているが、主キーは一つのテーブルに対して、z一つしか設定できないが、一意制約は複数の列に設定できる。

### 外部キーはどんな時に使われるのか?
## 一意制約

# 正規化
## 正規化って何?
データの冗長性（ムダのこと）を排除し、データに一貫性があり、かつ効率的にデータが扱えるようなテーブルにする行為・その方法論のこと

## 冗長的なデータって例えばどんなの？

## どうやって冗長的なデータを排除するの？
+ 段階的に正規化を行っていく
+ 正規化は1~5段階の過程があるが、一般的には第３正規化まで理解していれば問題
+ 各段階の正規化を順に見ていこう!

### 第一正規化
#### 第一正規化とは？
+ 一つのセル（便宜上、行列に交差するマスのことをセルという。）に複数の値が含まれる状態を無くす作業のこと
+ 
#### 第一正規化のゴールは？
+ 一つのセルには一つの値しかないテーブルにすることがゴールになります。
+ この「一つのセルには一つの値しか含まれない」ことを、スカラ値の原則といいます。
+ 言い換えると、第一正規化のゴールはスカラ値の原則を満たすことになります。

#### 「一つのセルに複数の値が入っていること」の何が問題なの？
+ 結論から言うと、「関数従属性を満たさないから」です。
+ 関数従属性とは、「xが決まればy列の値は一つに決まる」という性質のことでです。
+ 主キーの条件に、「ある値が決まれば、ある一つのレコードが定まること」がありましたが、実は他にも条件があります。
+ それが、この関数従属性です。つまり、「主キーが決まれば、ある列の値も一意に決まる」必要があります。
+ もし「一つのセルに複数の値が入っていること」を許してしまうと、主キーを定めると、ある列で複数の値を返すことになり、関数従属性を満たさなくなります。ここが問題点です。

##### 【問い】なぜ、主キーは関数従属性を満たさないといけないのか。一つの値に対して、複数の値が含まれることの何が問題になるのか。

#### どうやって第一正規化するの？
主に２つの方法がある。

セルに含まれる値の数だけ
1. 列を増やす（列持ち）
2. セルに含まれる値の数だけ、行を増やす。つまり行分割（行持ち）
基本的には、行持ちで正規化される。

#### 行持ちによる正規化だけでは問題がある
例えば、下記のように行持ちされた、扶養を持つ社員のテーブルの場合

| 社員ID | 社員名 |扶養|
----|----|----|
|1|佳代子|太郎|
|1|佳代子|次郎|
|1|佳代子|一郎|
|2|知恵|浩二|
|3|サニー||

##### 主キーが定まらない問題
+ 社員IDだけでは一つのレコードは特定できないし、社員名を含めても同様である。一つの行を特定するためには、前列を主キーにするしかない。
+ しかし、主キーにはNULLがあってはならないルールがある。
+ サニーのように、扶養のない社員だって存在するため、NULLが存在することになる。
+ よって、行分割だけでは主キーが定まらないため問題なんです。
+ じゃあ「扶養なし」のようなデータを設定すれば良いのではないか？確かにそうだが、ここで次の問題がでてくる

##### テーブルの意味やレコードの単位がわかりづらい問題
+ 現状のテーブルだと、社員と扶養の２つの情報が一つのテーブルに含まれているため、これが何のテーブルなのか、どうゆう単位で一つのレコードとしているのか分かりづらい問題がある。
以上の理由から行持ちだけでは正規化はできても、RDBのテーブルとしての機能が果たせなくなるから問題なんです！

##### 上記の問題を解決するためには？
+ 行分割と合わせて、テーブル分割+外部キー付与も行えば良いです。
+　上記の問題は、一つのテーブルに社員と扶養の２つの情報が含まれていることが問題なため、テーブルを分割します。
+ そして、扶養テーブルに扶養ID列を設ければ、わざわざ「子なし」のような値を用意しないでも、それぞれのテーブルで主キーを定めることができます。
+ さらに、一つのテーブルには一つの情報がまとまっているため、テーブルの意味もわかりやすく、レコードの単位も明瞭になります。
+ ただしこのままでは、各テーブルが独立したままで、関係性がないため、扶養テーブルは誰の社員の子なのかわからくなります。
+ そこで、扶養テーブルに外部キーをはることで、扶養テーブルは社員テーブルを参照するようにし、テーブル間の関係性を築きます。
これにより、上記の問題をクリアしつつ、親と子の関係性を持つ要件も満たすことが可能になります。

それだけではありません。外部キーを与えたことで、
1. 社員テーブルにないデータが、扶養テーブルに登録されることを防ぎますし（参照整合性制約）
2. 社員テーブルは扶養テーブルを気にすることなく、データを登録することができます。
3. 一方で、扶養テーブルで参照している社員が更新・削除されたら、反映させることも可能になります。
上記のようなメリットから、行分割+テーブル分割+外部キー付与の３ステップをとると良いでしょう！

# 第二正規化
## 第二正規化とは?

## 第二正規化のゴールは?
+ 第二正規形にすること
+ 第二正規形とは、完全関数従属にすること
+ 完全関数従属とは、全ての列が、主キーの全ての列に従属していること

## 完全関数従属の理解あってる？
+　完全関数従属=部分関数従属がない状態
+　部分関数従属がない状態=主キーの一部の列に対して、従属する列がない状態 
+　主キーの一部の列に対して、従属する列がない状態=全ての列が、主キーのすべての列に従属していること
　
## 関数従属を完全にするってどうゆうこと？
+ 
+ 例えば下記のような部署と社員を現したテーブルの場合

|部署ID |部署名| 社員ID | 社員名 
----|----|----|----|
|bb1|営業|aa1|佳代子|
|bb2|開発|aa2|知恵|
|bb3|総務|aa3|サニー|

### まず主キーを定める

ここでこの４列の従属関係を見ていきます。
1. 部署IDが決まれば、部署名が定まるため、「部署名は部署IDに従属」していることがわかります。
2. また、社員IDも同様に、社員IDが決まれば、社員名も定まるため、「社員名は社員IDに従属」しています。
3. 部署IDは部署IDに従属します。
4. 社員IDも同じ要領です。

+ 以上の工程から、このテーブルには、部署IDと社員IDの２つの従属先があることがわかります。
+ ということは、一つの列に従属していない
+ つまり、このテーブルは、関数従属が完全でないということになるわけです。

#### 従属しているとは何か？
+ xが定まればyが分かる状態のこと
+ yはxに属しているということ
